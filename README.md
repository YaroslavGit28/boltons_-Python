## Техническое задание на проект «boltons-practical»

**Название проекта:** boltons-practical  
**Тип проекта:** учебная Python-библиотека утилит  
---

### 1. Общая информация

**Цель проекта:** собрать небольшой, но аккуратно спроектированный пакет `boltons_practical`, который демонстрирует хорошие инженерные практики:
- понятный публичный API (реэкспорт из `__init__.py`);
- типизация;
- модульные тесты;
- “безопасные” реализации популярных утилит.

**Для кого:** для учебного курса «Исследование и практическое применение инженерного инструмента».

---

### 2. Возможности библиотеки

#### 2.1 `fileutils` — безопасная работа с файловой системой

- **`ensure_dir()` / `mkdir_p()`**: гарантированно создают директорию (аналог `mkdir -p`)
- **`iter_find_files()`**: ленивый поиск файлов по glob‑маске (`Path.rglob`)
- **`safe_write_text()`**: атомарная запись текста через временный файл и `replace()`
- **`copy_file_atomic()`**: безопасное копирование файла через временный файл
- **`read_text_lines()`**: удобное чтение файла построчно
- **`touch()`**: аналог Unix‑команды `touch`

#### 2.2 `dictutils` — операции над словарями

- **`FrozenDict`**: иммутабельный и хэшируемый словарь
- **`merge_dicts()`**: слияние словарей (в т.ч. глубокое)
- **`pick()` / `omit()`**: выбор или исключение подмножеств ключей

#### 2.3 `iterutils` — работа с потоками данных

- **`chunked()`**: разбиение на чанки фиксированного размера
- **`windowed()`**: скользящее окно по последовательности
- **`unique_everseen()`**: удаление дубликатов с сохранением порядка

#### 2.4 `functional` — утилиты функционального стиля

- **`compose()`**: композиция функций `f(g(h(x)))`
- **`memoize()`**: мемоизация результата функции с опциональным TTL

---

### 3. Требования

- Python **3.10+**
- (Для разработки) зависимости из extra `dev`: `pytest`, `ruff`, `mypy`

---

### 4. Структура проекта

```text
.
├─ pyproject.toml                 # метаданные проекта и зависимости
├─ README.md                      # основная документация
├─ docs/                          # расширенная документация по модулям
│  ├─ index.md
│  ├─ usage.md
│  ├─ api.md
│  ├─ fileutils.md
│  ├─ dictutils.md
│  ├─ iterutils.md
│  ├─ functional.md
│  └─ sources.md
├─ src/
│  └─ boltons_practical/
│     ├─ __init__.py              # публичный API пакета (реэкспорт функций)
│     ├─ fileutils.py
│     ├─ dictutils.py
│     ├─ iterutils.py
│     └─ functional.py
└─ tests/                         # модульные тесты для всех утилит
   ├─ test_fileutils.py
   ├─ test_dictutils.py
   ├─ test_iterutils.py
   └─ test_functional.py
```

---

### 5. Как использовать

#### Установка и запуск (локально)

1) Создайте и активируйте виртуальное окружение.

Windows (PowerShell):

```bash
python -m venv .venv
.venv\Scripts\Activate.ps1
```

Linux / macOS:

```bash
python3 -m venv .venv
source .venv/bin/activate
```

2) Установите пакет в режиме разработки (вместе с dev-зависимостями):

```bash
pip install -e ".[dev]"
```

После этого модуль `boltons_practical` доступен в Python как обычная установленная библиотека.

#### Запуск тестов

```bash
pytest -q
```

---

### 6. Быстрый старт (пример использования)

```python
from boltons_practical import (
    FrozenDict,
    chunked,
    compose,
    ensure_dir,
    memoize,
    safe_write_text,
)

# fileutils
ensure_dir("data/tmp")
safe_write_text("data/tmp/hello.txt", "one\ntwo\n")

# iterutils
print(list(chunked(range(7), 3)))  # [[0, 1, 2], [3, 4, 5], [6]]

# dictutils
cfg = FrozenDict({"env": "dev", "debug": True})
print(cfg["env"])  # dev

# functional
to_upper_str = compose(str.upper, str)
print(to_upper_str(cfg["env"]))  # DEV

@memoize(ttl=0.1)
def add(a: int, b: int) -> int:
    return a + b

print(add(1, 2))  # 3
print(add(1, 2))  # 3 (из кеша)
```

---

### 7. Демонстрации (смысл утилит на мини-примерах)

#### 7.1 Атомарная запись файла (`safe_write_text`)

Идея: сначала записать во временный файл, затем заменить целевой “одним движением” (`Path.replace()`), чтобы снизить риск получить повреждённый файл.

#### 7.2 Иммутабельные конфиги (`FrozenDict`)

Идея: удобно хранить конфигурации и использовать их как ключи в словарях/множествах, так как `FrozenDict` хэшируемый.

#### 7.3 Потоковая обработка (`chunked`, `windowed`, `unique_everseen`)

Идея: функции возвращают итераторы и подходят для больших последовательностей — можно обрабатывать данные лениво.

#### 7.4 Мемоизация с TTL (`memoize`)

Идея: ускорить повторные вызовы “дорогих” функций; TTL позволяет автоматически инвалидировать кеш.

---

### 8. Ключевые концепции (что демонстрирует проект)

- **Публичный API пакета**: реэкспорт функций/классов через `boltons_practical.__init__`
- **Типизация**: использование `typing`/`collections.abc` и аннотаций
- **Генераторы и ленивые вычисления**: итераторные утилиты возвращают `Iterator[...]`
- **Безопасные операции с файлами**: атомарная запись/копирование через временные файлы
- **Тестируемость**: ключевые сценарии покрыты `pytest`-тестами

---

### 9. Документация

Подробные страницы лежат в папке `docs/`:
- `docs/index.md` — оглавление
- `docs/usage.md` — установка, тесты, быстрый старт
- `docs/api.md` — публичный API и реэкспорты
- `docs/fileutils.md`, `docs/dictutils.md`, `docs/iterutils.md`, `docs/functional.md` — документация по модулям
- `docs/sources.md` — использованные источники




